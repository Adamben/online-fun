<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>2D Shooter w/ Full Sync, Touch & Sound</title>
  <style>
    html, body { margin:0; padding:0; width:100%; height:100%; overflow:hidden; touch-action:none; }
    canvas { display:block; background:#222; }
    /* Overlays */
    #startOverlay, #endOverlay {
      position:absolute; top:0; left:0; right:0; bottom:0;
      background:rgba(0,0,0,0.8); color:white;
      display:flex; flex-direction:column; align-items:center; justify-content:center;
      z-index:100;
    }
    #endOverlay { display:none; }
    #startOverlay input, #startOverlay button, #endOverlay button {
      margin:4px; padding:8px; font-size:16px;
    }
    /* HUD */
    #ui { position:absolute; top:10px; left:10px; color:white; z-index:5; }
    #ui div { margin-bottom:4px; }
    /* Joystick zones */
    .joystick-zone {
      position:absolute; width:150px; height:150px;
      z-index:10;
    }
    #leftZone  { bottom:20px; left:20px; }
    #rightZone { bottom:20px; right:20px; }
  </style>
  <!-- PeerJS & NippleJS -->
  <script src="https://cdn.jsdelivr.net/npm/peerjs@1.4.7/dist/peerjs.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/nipplejs@0.9.0/dist/nipplejs.min.js"></script>
</head>
<body>
  <canvas id="game"></canvas>

  <!-- Start / End Overlays -->
  <div id="startOverlay">
    <h1>2D Shooter</h1>
    <div>
      <label>Your ID: <input id="myId" placeholder="peer‑id"></label>
      <button id="initPeer">Init</button>
    </div>
    <div>
      <label>Connect to: <input id="otherId" placeholder="peer‑id"></label>
      <button id="connectPeer">Connect</button>
    </div>
    <button id="startGame">Start</button>
    <div id="connStatus"></div>
  </div>
  <div id="endOverlay">
    <h1 id="endMsg"></h1>
    <button id="rematch">Rematch</button>
  </div>

  <!-- HUD -->
  <div id="ui">
    <div>You: <progress id="myHealth" value="5" max="5"></progress></div>
    <div>Enemy: <progress id="otherHealth" value="5" max="5"></progress></div>
  </div>

  <!-- Joystick containers -->
  <div id="leftZone" class="joystick-zone"></div>
  <div id="rightZone" class="joystick-zone"></div>

  <script>
  // —— Setup & State ——
  const canvas = document.getElementById('game'), ctx = canvas.getContext('2d');
  function resize(){ canvas.width=innerWidth; canvas.height=innerHeight; }
  window.addEventListener('resize', resize); resize();

  const size = 40;
  let frameCount = 0;
  let me =    { x:size, y:canvas.height/2, angle:0, alive:true, health:5, dabTime:0 };
  let other = { x:canvas.width-size, y:canvas.height/2, angle:0, alive:true, health:5, dabTime:0 };
  let bullets = [], debris = [];

  const myCols    = ['#4af','#6cf'],
        otherCols = ['#fa4','#fc6'];

  let leftStick = { x:0, y:0 };
  let lastRightVec = { x:0, y:0 };

  // —— Joysticks via NippleJS ——
  const leftManager = nipplejs.create({
    zone: document.getElementById('leftZone'),
    mode: 'static', position: { left: '50%', top: '50%' },
    color: 'white', size: 150
  });
  leftManager.on('move', (_, data) => {
    leftStick.x = data.vector.x;
    leftStick.y = -data.vector.y;            // invert Y
  });
  leftManager.on('end', () => {
    leftStick.x = 0; leftStick.y = 0;
  });

  const rightManager = nipplejs.create({
    zone: document.getElementById('rightZone'),
    mode: 'static', position: { left: '50%', top: '50%' },
    color: 'white', size: 150
  });
  rightManager.on('move', (_, data) => {
    const vx = data.vector.x;
    const vy = -data.vector.y;               // invert Y
    lastRightVec.x = vx;
    lastRightVec.y = vy;
    me.angle = Math.atan2(vy, vx);
  });
  rightManager.on('end', () => {
    // if the stick was pushed, launch in that direction
    const mag = Math.hypot(lastRightVec.x, lastRightVec.y);
    if (mag > 0.2) {
      me.angle = Math.atan2(lastRightVec.y, lastRightVec.x);
      shoot();
    }
    lastRightVec.x = 0;
    lastRightVec.y = 0;
  });

  // —— Tap-to-Shoot ——
  document.addEventListener('touchstart', ev => {
    const t = ev.touches[0];
    if (t.clientY > canvas.height * 0.75) {
      me.angle = Math.atan2(t.clientY - me.y, t.clientX - me.x);
      shoot();
    }
  });

  // —— Audio Beeps ——
  const audioCtx = new (window.AudioContext||window.webkitAudioContext)();
  function playBeep(freq, duration=0.1){
    const osc = audioCtx.createOscillator(),
          gain = audioCtx.createGain();
    osc.frequency.value = freq;
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.start();
    gain.gain.setValueAtTime(1, audioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);
    osc.stop(audioCtx.currentTime + duration);
  }

  // —— Shooting & Damage ——
  function shoot(){
    if (!me.alive) return;
    bullets.push({
      x: me.x + Math.cos(me.angle)*size/2,
      y: me.y + Math.sin(me.angle)*size/2,
      vx: Math.cos(me.angle)*8,
      vy: Math.sin(me.angle)*8,
      owner: 'me'
    });
    dab(me);
    playBeep(600, 0.05);
    send({ shoot: true, pos: [me.x, me.y], angle: me.angle });
  }
  function dab(p){ p.dabTime = 20; }
  function explode(x,y){
    for(let i=0;i<12;i++){
      debris.push({
        x,y,
        vx:(Math.random()*2-1)*5,
        vy:(Math.random()*2-1)*5,
        life:60
      });
    }
  }
  function meDie(){
    me.alive = false;
    explode(me.x, me.y);
    playBeep(110, 0.3);
    send({ die:true });
    showEnd('You Lose');
  }
  function otherDie(){
    other.alive = false;
    explode(other.x, other.y);
    playBeep(880, 0.3);
    showEnd('You Win');
  }

  // —— Health Sync ——
  const myHP = document.getElementById('myHealth'), oHP = document.getElementById('otherHealth');
  function updateHP(){
    myHP.value = me.health;
    oHP.value  = other.health;
  }
  function takeDamage(){
    me.health = Math.max(0, me.health - 1);
    playBeep(200, 0.1);
    updateHP();
    flashScreen();
    send({ health: me.health });
    if (me.health <= 0) meDie();
  }
  function flashScreen(){
    canvas.style.backgroundColor = '#400';
    setTimeout(() => canvas.style.backgroundColor = '#222', 100);
  }

  // —— Bullet Logic ——
  function processBullets(){
    bullets = bullets.filter(b => {
      b.x += b.vx; b.y += b.vy;
      if (b.owner==='me' && other.alive &&
          Math.hypot(b.x-other.x,b.y-other.y) < size) {
        dab(other);
        return false;
      }
      if (b.owner==='other' && me.alive &&
          Math.hypot(b.x-me.x,b.y-me.y) < size) {
        takeDamage();
        return false;
      }
      return b.x>=0 && b.x<=canvas.width && b.y>=0 && b.y<=canvas.height;
    });
  }

  // —— Networking & Voice ——
  let peer, conn;
  const status = document.getElementById('connStatus');

  document.getElementById('initPeer').onclick = () => {
    const id = document.getElementById('myId').value.trim();
    if (!id) return alert('Enter your peer ID');
    peer = new Peer(id);
    peer.on('open', () => status.textContent = `Ready: ${id}`);
    peer.on('connection', c => { conn = c; setupConn(); });
  };
  document.getElementById('connectPeer').onclick = () => {
    if (!peer) return alert('Init first');
    conn = peer.connect(document.getElementById('otherId').value.trim());
    setupConn();
  };

  function setupConn(){
    conn.on('open', () => {
      status.textContent = 'Connected!';
      navigator.mediaDevices.getUserMedia({audio:true})
        .then(stream => {
          const call = peer.call(conn.peer, stream);
          call.on('stream', playStream);
        })
        .catch(err => console.error('Mic access failed:', err));
    });
    peer.on('call', c => {
      navigator.mediaDevices.getUserMedia({audio:true})
        .then(stream => {
          c.answer(stream);
          c.on('stream', playStream);
        })
        .catch(err => console.error('Mic access failed:', err));
    });
    conn.on('data', d => {
      if (d.pos)      [other.x, other.y] = d.pos;
      if (d.angle!=null) other.angle = d.angle;
      if (d.shoot) {
        bullets.push({
          x: d.pos[0] + Math.cos(d.angle)*size/2,
          y: d.pos[1] + Math.sin(d.angle)*size/2,
          vx: Math.cos(d.angle)*8,
          vy: Math.sin(d.angle)*8,
          owner:'other'
        });
      }
      if (d.health != null) {
        other.health = d.health;
        updateHP();
        if (other.health <= 0) otherDie();
      }
      if (d.die) otherDie();
    });
  }

  function playStream(stream){
    const audio = document.createElement('audio');
    audio.srcObject = stream;
    audio.autoplay = true;
    document.body.appendChild(audio);
  }

  function send(obj){
    if (conn && conn.open) conn.send(Object.assign({ pos: [me.x, me.y], angle: me.angle }, obj));
  }

  // —— Start / End UI ——
  document.getElementById('startGame').onclick = () => {
    document.getElementById('startOverlay').style.display = 'none';
  };
  const endOv = document.getElementById('endOverlay'),
        endMsg= document.getElementById('endMsg');
  function showEnd(msg){
    endMsg.textContent = msg;
    endOv.style.display = 'flex';
  }
  document.getElementById('rematch').onclick = () => {
    me =    { x:size, y:canvas.height/2, angle:0, alive:true, health:5, dabTime:0 };
    other = { x:canvas.width-size, y:canvas.height/2, angle:0, alive:true, health:5, dabTime:0 };
    bullets = []; debris = [];
    updateHP();
    endOv.style.display = 'none';
    send({ health: me.health });
  };

  // —— Main Loop ——
  function loop(){
    frameCount++;
    if(me.alive){
      const sp = 4;
      me.x = Math.max(size/2, Math.min(canvas.width-size/2, me.x + leftStick.x*sp));
      me.y = Math.max(size/2, Math.min(canvas.height-size/2, me.y + leftStick.y*sp));
    }
    processBullets();
    send({});  // broadcast position/angle
    debris = debris.filter(d => { d.x+=d.vx; d.y+=d.vy; return --d.life>0; });

    ctx.clearRect(0,0,canvas.width,canvas.height);
    const mc = myCols[Math.floor(frameCount/15)%2],
          oc = otherCols[Math.floor(frameCount/15)%2];

    if(other.alive){
      ctx.save();
      ctx.translate(other.x,other.y);
      if(other.dabTime-->0) ctx.rotate(Math.PI/4);
      else ctx.rotate(other.angle);
      ctx.fillStyle = oc;
      ctx.fillRect(-size/2,-size/2,size,size);
      ctx.restore();
    }
    if(me.alive){
      ctx.save();
      ctx.translate(me.x,me.y);
      if(me.dabTime-->0) ctx.rotate(-Math.PI/4);
      else ctx.rotate(me.angle);
      ctx.fillStyle = mc;
      ctx.fillRect(-size/2,-size/2,size,size);
      ctx.restore();
    }
    bullets.forEach(b=>{
      ctx.fillStyle = '#fff';
      ctx.beginPath(); ctx.arc(b.x,b.y,5,0,2*Math.PI); ctx.fill();
    });
    debris.forEach(d=>{
      ctx.fillStyle = '#888';
      ctx.fillRect(d.x-4,d.y-4,8,8);
    });

    requestAnimationFrame(loop);
  }

  updateHP();
  loop();
  </script>
</body>
</html>
