<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>2D Multiplayer Shooter w/ Voice Chat</title>
  <style>
    html, body { margin:0; padding:0; width:100%; height:100%; overflow:hidden; }
    canvas { display:block; background:#222; }
    #startOverlay, #endOverlay {
      position:absolute; top:0; left:0; right:0; bottom:0;
      background:rgba(0,0,0,0.8);
      display:flex; flex-direction:column; align-items:center; justify-content:center;
      color:white; z-index:100;
    }
    #startOverlay input, #startOverlay button,
    #endOverlay button { padding:8px; margin:4px; font-size:16px; }
    #scope {
      position:absolute; top:50%; left:50%;
      width:200px; height:200px; margin:-100px 0 0 -100px;
      border:4px solid rgba(255,255,255,0.7); border-radius:50%;
      pointer-events:none; display:none; z-index:5;
    }
    #ui {
      position:absolute; top:10px; left:10px; z-index:5; color:white;
    }
    #ui div { margin-bottom:4px; }
    #peerControls {
      position:absolute; bottom:10px; left:10px; z-index:5;
      color:white; background:rgba(0,0,0,0.5); padding:8px; border-radius:4px;
    }
    #peerControls input { width:100px; margin-right:4px; }
  </style>
</head>
<body>
  <canvas id="game"></canvas>

  <!-- Start -->
  <div id="startOverlay">
    <h1>2D Shooter</h1>
    <div>
      <label>Your ID: <input id="myId" placeholder="peer-id"></label>
      <button id="initPeer">Init</button>
    </div>
    <div>
      <label>Connect to: <input id="otherId" placeholder="peer-id"></label>
      <button id="connectPeer">Connect</button>
    </div>
    <button id="startGame">Start</button>
    <div id="connStatus"></div>
  </div>

  <!-- End -->
  <div id="endOverlay" style="display:none">
    <h1 id="endMsg"></h1>
    <button id="rematch">Rematch</button>
  </div>

  <!-- Scope -->
  <div id="scope"></div>

  <!-- HUD -->
  <div id="ui">
    <div>You: <progress id="myHealth" value="5" max="5"></progress></div>
    <div>Enemy: <progress id="otherHealth" value="5" max="5"></progress></div>
  </div>

  <!-- Peer Controls / Voice -->
  <div id="peerControls">
    <label><input type="checkbox" id="voiceToggle"> Voice Chat</label>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/peerjs@1.4.7/dist/peerjs.min.js"></script>
  <script>
  // Canvas
  const canvas = document.getElementById('game'), ctx = canvas.getContext('2d');
  function resize(){ canvas.width = innerWidth; canvas.height = innerHeight; }
  window.addEventListener('resize', resize); resize();

  // Game state
  const size = 40;
  let me = { x: size, y: canvas.height/2, angle:0, alive:true, color:'#4af', health:5, dabTime:0 };
  let other = { x: canvas.width - size, y: canvas.height/2, angle:0, alive:true, color:'#fa4', health:5, dabTime:0 };
  let bullets = [], debris = [];

  // Controls
  const keys = {};
  window.addEventListener('keydown', e=> keys[e.code]=true);
  window.addEventListener('keyup',   e=> keys[e.code]=false);
  let mouse = { x:0, y:0 };
  canvas.addEventListener('mousemove', e=>{
    const r = canvas.getBoundingClientRect();
    mouse.x = e.clientX - r.left;
    mouse.y = e.clientY - r.top;
    me.angle = Math.atan2(mouse.y - me.y, mouse.x - me.x);
  });
  canvas.addEventListener('mousedown', () => shoot());

  // Shoot
  function shoot(){
    if(!me.alive) return;
    bullets.push({
      x: me.x + Math.cos(me.angle)*size/2,
      y: me.y + Math.sin(me.angle)*size/2,
      vx: Math.cos(me.angle)*8,
      vy: Math.sin(me.angle)*8,
      owner: 'me'
    });
    doDab(true);
    send({ shoot:true });
  }

  // Dab tilt
  function doDab(isLocal){
    const p = isLocal? me: other;
    p.dabTime = 20;
  }

  // Explosion
  function explode(x,y,color){
    for(let i=0;i<12;i++){
      debris.push({
        x,y,
        vx:(Math.random()*2-1)*5,
        vy:(Math.random()*2-1)*5,
        life:60,
        color
      });
    }
  }

  // Death handlers
  function meDie(){
    me.alive = false;
    explode(me.x, me.y, me.color);
    send({ die:true });
    showEnd('You Lose');
  }
  function otherDie(){
    other.alive = false;
    explode(other.x, other.y, other.color);
    showEnd('You Win');
  }

  // Health UI
  const myHP = document.getElementById('myHealth'),
        oHP  = document.getElementById('otherHealth');
  function updateHP(){
    myHP.value = me.health;
    oHP.value  = other.health;
  }

  // Process bullets
  function processBullets(){
    bullets = bullets.filter(b=>{
      b.x += b.vx; b.y += b.vy;
      // collision
      if(b.owner==='me' && other.alive){
        if(Math.hypot(b.x-other.x,b.y-other.y) < size){
          other.health--;
          updateHP();
          send({ hit:true });
          if(other.health<=0) otherDie();
          return false;
        }
      }
      if(b.owner==='other' && me.alive){
        if(Math.hypot(b.x-me.x,b.y-me.y) < size){
          me.health--;
          updateHP();
          if(me.health<=0) meDie();
          return false;
        }
      }
      // bounds
      return b.x>=0 && b.x<=canvas.width && b.y>=0 && b.y<=canvas.height;
    });
  }

  // Networking & Voice
  let peer, conn, localStream;
  const status = document.getElementById('connStatus');

  document.getElementById('initPeer').onclick = ()=>{
    const id = document.getElementById('myId').value.trim();
    if(!id) return alert('Enter your peer ID');
    peer = new Peer(id);
    peer.on('open', ()=> status.textContent = `Peer ready: ${id}`);
    peer.on('connection', c=>{ conn=c; setupConn(); });
    // prepare voice
    navigator.mediaDevices.getUserMedia({ audio:true }).then(s=> localStream = s);
  };

  document.getElementById('connectPeer').onclick = ()=>{
    if(!peer) return alert('Init first');
    const otherId = document.getElementById('otherId').value.trim();
    conn = peer.connect(otherId);
    setupConn();
  };

  function setupConn(){
    conn.on('open', ()=>{
      status.textContent = 'Connected!';
      // voice call
      if(localStream && document.getElementById('voiceToggle').checked){
        const call = peer.call(conn.peer, localStream);
        call.on('stream', playStream);
      }
    });
    // answer incoming voice call
    peer.on('call', c=>{
      if(localStream) {
        c.answer(localStream);
        c.on('stream', playStream);
      }
    });
    conn.on('data', d=>{
      if(d.pos)    [other.x, other.y] = d.pos;
      if(d.angle!=null) other.angle = d.angle;
      if(d.shoot)  bullets.push({
                      x: other.x + Math.cos(other.angle)*size/2,
                      y: other.y + Math.sin(other.angle)*size/2,
                      vx: Math.cos(other.angle)*8,
                      vy: Math.sin(other.angle)*8,
                      owner: 'other'
                    });
      if(d.dab)    doDab(false);
      if(d.hit){
        other.health--;
        updateHP();
        if(other.health<=0) otherDie();
      }
      if(d.die)    otherDie();
    });
  }

  function playStream(stream){
    const audio = document.createElement('audio');
    audio.srcObject = stream;
    audio.autoplay = true;
    document.body.appendChild(audio);
  }

  function send(obj){
    if(conn && conn.open) conn.send({
      pos:[me.x, me.y],
      angle:me.angle,
      shoot:obj.shoot||false,
      dab:obj.dab||false,
      hit:obj.hit||false,
      die:obj.die||false
    });
  }

  // Start / End
  document.getElementById('startGame').onclick = ()=>{
    document.getElementById('startOverlay').style.display = 'none';
  };
  const endOv = document.getElementById('endOverlay'),
        endMsg = document.getElementById('endMsg');
  function showEnd(msg){
    endMsg.textContent = msg;
    endOv.style.display = 'flex';
  }
  document.getElementById('rematch').onclick = ()=>{
    // reset state
    me = { x: size, y: canvas.height/2, angle:0, alive:true, color:'#4af', health:5, dabTime:0 };
    other = { x: canvas.width-size, y:canvas.height/2, angle:0, alive:true, color:'#fa4', health:5, dabTime:0 };
    bullets = []; debris = [];
    updateHP();
    endOv.style.display = 'none';
  };

  // Main loop
  function loop(){
    // movement
    if(me.alive){
      if(keys['KeyW']) me.y -= 4;
      if(keys['KeyS']) me.y += 4;
      if(keys['KeyA']) me.x -= 4;
      if(keys['KeyD']) me.x += 4;
    }

    processBullets();
    send({}); // send position/angle

    // update debris
    debris = debris.filter(d=>{
      d.x += d.vx; d.y += d.vy; d.life--;
      return d.life>0;
    });

    // draw
    ctx.clearRect(0,0,canvas.width,canvas.height);

    // other
    if(other.alive){
      ctx.save();
      ctx.translate(other.x, other.y);
      if(other.dabTime>0){ ctx.rotate(Math.PI/4); other.dabTime--; }
      else ctx.rotate(other.angle);
      ctx.fillStyle = other.color;
      ctx.fillRect(-size/2,-size/2,size,size);
      ctx.restore();
    }

    // me
    if(me.alive){
      ctx.save();
      ctx.translate(me.x, me.y);
      if(me.dabTime>0){ ctx.rotate(-Math.PI/4); me.dabTime--; }
      else ctx.rotate(me.angle);
      ctx.fillStyle = me.color;
      ctx.fillRect(-size/2,-size/2,size,size);
      ctx.restore();
    }

    // bullets
    bullets.forEach(b=>{
      ctx.fillStyle = '#fff';
      ctx.beginPath(); ctx.arc(b.x,b.y,5,0,2*Math.PI); ctx.fill();
    });

    // debris
    debris.forEach(d=>{
      ctx.fillStyle = d.color;
      ctx.fillRect(d.x-4,d.y-4,8,8);
    });

    requestAnimationFrame(loop);
  }
  updateHP(); loop();
  </script>
</body>
</html>
